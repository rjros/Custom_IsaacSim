parser.add_argument("--beam_length", type=float, default=0.10, 
                    help="Beam length in meters")
parser.add_argument("--beam_width", type=float, default=0.03, 
                    help="Beam width in meters")
parser.add_argument("--beam_height", type=float, default=0.03, 
                    help="Beam height in meters")
parser.add_argument("--resolution", type=int, default=30, 
                    help="Simulation mesh resolution (elements along longest dimension). "
                         "Recommended: 20=fast, 30=balanced, 40=accurate")
parser.add_argument("--solver_iterations", type=int, default=130,
                    help="Position solver iterations per timestep. "
                         "Recommended: 30=fast, 40=balanced, 50=accurate")
parser.add_argument("--max_time", type=float, default=10, 
                    help="Simulation time in seconds")
args, unknown = parser.parse_known_args()        
        
        self.deformable_material = DeformableMaterial(
            prim_path=deformable_material_path,
            dynamic_friction=0.5,
            youngs_modulus=263824.0,    # E (will be calibrated in paper)
            poissons_ratio=0.4999,      # ν = 0.4999 (nearly incompressible)
            damping_scale=0.01,          # No artificial damping
            elasticity_damping=0.0,
            # density=1070.0              # ρ = 1,070 kg/m³
        )

        print(f"\nDeformable Configuration:")
        print(f"  Beam: {self.beam_length*100:.1f}cm × {self.beam_width*100:.1f}cm × {self.beam_height*100:.1f}cm")
        print(f"  Resolution: {self.resolution} elements (longest dimension)")
        print(f"  Solver iterations: {args.solver_iterations}")
        
        self.deformable = SingleDeformablePrim(
            name="dragonSkinBeam",
            prim_path=str(mesh_path),
            deformable_material=self.deformable_material,
            vertex_velocity_damping=0.0,
            sleep_damping=0.0,
            sleep_threshold=0.001,
            settling_threshold=0.0,
            self_collision=False,
            solver_position_iteration_count=args.solver_iterations,
            kinematic_enabled=False,
            simulation_hexahedral_resolution=self.resolution,
            collision_simplification=False,
        )
        self.my_world.scene.add(self.deformable)